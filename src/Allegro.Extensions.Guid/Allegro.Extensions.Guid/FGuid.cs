using System.Globalization;
using IdGen;

// ReSharper disable ArgumentsStyleNamedExpression
namespace Allegro.Extensions.Guid;

// TODO: add serializers, swagger support etc. It should behave like Guid / string (equality etc.)

/// <summary>
/// Twitter Snowflake-alike ID generator for .NET based on IP+Mask+ClusterNumber. 64 bit Id's.
/// </summary>
public readonly partial struct FGuid
{
    private readonly long _value;

    private FGuid(long value) => _value = value;

    /// <summary>
    /// Encodes long uuid generated by <see cref="GenerateLong"/>
    /// </summary>
    public static string Generate() => ToString(GenerateLong());

    /// <summary>
    /// Encodes long uuid generated by <see cref="GenerateLong"/>
    /// </summary>
    public static FGuid NewGuid() => new(GenerateLong());

    /// <summary>
    /// "2328390861371856896" instead of "FGuid { }" or "Allegro.Extensions.Guid.FGuid"
    /// </summary>
    public override string ToString() => ToString(_value);

    /// <summary>
    /// Parse from string
    /// </summary>
    public static FGuid Parse(string input)
    {
        var parsed = TryParse(input, out var result);
        return !parsed ? throw new ArgumentException("Could not parse FGuid", nameof(input)) : result;
    }

    /// <summary>
    /// Try parse from string
    /// </summary>
    public static bool TryParse(string? input, out FGuid result)
    {
        if (input is null)
        {
            result = default;
            return false;
        }

        var fGuidString = input.Trim(); // Remove whitespace from beginning and end

        if (fGuidString.Length == 0)
        {
            result = default;
            return false;
        }

        var longParsed = long.TryParse(fGuidString, out var fGuidLong);

        if (!longParsed)
        {
            result = default;
            return false;
        }

        result = new FGuid(fGuidLong);
        return true;
    }

    private static string ToString(long value) => value.ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
}

/// <summary>
/// Generates long uuid representation using Twitters Snowflake algorithm implementation:
/// https://github.com/RobThree/IdGen
/// </summary>
public readonly partial struct FGuid
{
    /// <summary>
    /// Create long uuid using generator
    /// </summary>
    public static long GenerateLong() => Generator.CreateId();

    // generator must be a singleton
    private static GeneratorOptions? _options;
    private static GeneratorOptions Options => _options ??= GetDefaultOptions();
    private static IdGeneratorOptions? _idOptions;
    private static IdGeneratorOptions IdOptions => _idOptions ??= GetOptions(Options.IdStructure);
    private static IdGenerator? _generator;

    private static IdGenerator Generator =>
        _generator ??= new IdGenerator(GetGeneratorId(IdOptions, Options), IdOptions);

    /// <summary>
    /// Get formatted configuration (used for audit)
    /// </summary>
    public static string GetFormattedConfiguration() => $"GeneratorId: {Generator.Id}, Options: {Options}";

    /// <summary>
    /// Allow to override default generator options (machine ip etc.)
    /// Must be executed before first GenerateLong.
    /// </summary>
    public static void SetOptions(GeneratorOptions options)
    {
        if (_options is not null)
        {
            throw new ArgumentException("Options already set", nameof(options));
        }

        _options = options;
    }

    private static GeneratorOptions GetDefaultOptions() =>
        new(
            new GeneratorIdStructureOptions(
                TimestampBits: GeneratorDefaultOptions.TimestampBits,
                GeneratorIpBits: GeneratorDefaultOptions.GeneratorIpBits,
                GeneratorClusterBits: GeneratorDefaultOptions.GeneratorClusterBits,
                SequenceBits: GeneratorDefaultOptions.SequenceBits),
            !string.IsNullOrWhiteSpace(GeneratorDefaultOptions.Ip)
                ? new GeneratorMachineOptions(
                    Ip: GeneratorDefaultOptions.Ip,
                    Netmask: GeneratorDefaultOptions.Netmask,
                    ClusterNumber: GeneratorDefaultOptions.ClusterNumber) : null);

    private static IdGeneratorOptions GetOptions(GeneratorIdStructureOptions options) =>
        new(
            new IdStructure(
                options.TimestampBits,
                options.GeneratorIdBitsWithCluster,
                options.SequenceBits),
            new DefaultTimeSource(IdGeneratorOptions.DefaultEpoch), // 2015.01.01T00:00:00
            SequenceOverflowStrategy.SpinWait); // lightweight synchronization strategy

    private static int GetGeneratorId(IdGeneratorOptions idOptions, GeneratorOptions options)
    {
        if (options.Machine is not null)
        {
            var sequence = GetSequenceNumber(options.Machine.Value.Ip, options.Machine.Value.Netmask);
            var sequenceWithClusterNumber = AddClusterNumber(options.Machine.Value.ClusterNumber, sequence, options.IdStructure.GeneratorIpBits);
            return sequenceWithClusterNumber % idOptions.IdStructure.MaxGenerators;
        }
        else
        {
            var sequence = new Random().Next(idOptions.IdStructure.MaxGenerators);
            return sequence % idOptions.IdStructure.MaxGenerators;
        }
    }

    internal static int GetSequenceNumber(string ip, int netmask)
    {
        if (string.IsNullOrEmpty(ip))
        {
            OutOfRange();
        }

        var segments = ip.Split('.');

        if (segments.Length != 4)
        {
            OutOfRange();
        }

        var sequenceChars =
            segments
                .Select(s => int.TryParse(s, out var sInt) ? Convert.ToString(sInt, 2).PadLeft(8, '0') : OutOfRange())
                .Aggregate(string.Empty, (s, s1) => s + s1);

        var sequence = new string(sequenceChars.Skip(netmask).ToArray());
        return Convert.ToInt32(sequence, 2);

        string OutOfRange() => throw new ArgumentOutOfRangeException(nameof(ip), $"Ip out of range: {ip}");
    }

    internal static int AddClusterNumber(int clusterNumber, int ipSequence, byte ipSequenceLength)
    {
        var shiftedClusterNumber = clusterNumber << ipSequenceLength;
        var sequenceWithClusterNumber = shiftedClusterNumber ^ ipSequence;
        return sequenceWithClusterNumber;
    }

    /// <summary>
    /// Length depends on settings
    /// </summary>
    internal static int GetMaxLength()
    {
        var bits =
            Options.IdStructure.SequenceBits +
            Options.IdStructure.TimestampBits +
            Options.IdStructure.GeneratorIdBitsWithCluster
            + 1; // sign bit

        var maxNumber = (long)Math.Pow(2, bits) - 1;

        var encoded = maxNumber.ToString(CultureInfo.InvariantCulture);

        return encoded.Length;
    }

    /// <summary>
    /// For testing purposes.
    /// </summary>
    internal static void ResetOptions()
    {
        _options = null;
    }
}

/// <summary>
/// FGuid generator options
/// </summary>
public readonly record struct GeneratorOptions(
    GeneratorIdStructureOptions IdStructure,
    GeneratorMachineOptions? Machine);

/// <summary>
/// Id structure options
/// </summary>
public readonly record struct GeneratorIdStructureOptions(
    byte TimestampBits,
    byte GeneratorIpBits,
    byte GeneratorClusterBits,
    byte SequenceBits)
{
    internal byte GeneratorIdBitsWithCluster => Convert.ToByte(GeneratorIpBits + GeneratorClusterBits); // might overflow
}

/// <summary>
/// Machine options
/// </summary>
public readonly record struct GeneratorMachineOptions(
    string Ip,
    int Netmask,
    int ClusterNumber);

internal static class GeneratorDefaultOptions
{
    internal const byte TimestampBits = 40;
    internal const byte GeneratorIpBits = 11;
    internal const byte GeneratorClusterBits = 2;
    internal const byte SequenceBits = 10;

    private const byte DefaultNetmask = 21;
    private const byte DefaultClusterNumber = 0;

    internal static readonly string? Ip = Environment.GetEnvironmentVariable("Pod__Ip__Address"); // K8S status.podIP

    private static readonly string? NetmaskOverride = Environment.GetEnvironmentVariable("Ip__Netmask");
    private static readonly string? ClusterNumberOverride = Environment.GetEnvironmentVariable("Cluster__Number");

    internal static int Netmask =>
        !string.IsNullOrEmpty(NetmaskOverride) &&
        int.TryParse(NetmaskOverride, out var netmaskOverrideParsed)
            ? netmaskOverrideParsed
            : DefaultNetmask;

    internal static int ClusterNumber =>
        !string.IsNullOrEmpty(ClusterNumberOverride) &&
        int.TryParse(ClusterNumberOverride, out var clusterOverrideParsed)
            ? clusterOverrideParsed
            : DefaultClusterNumber;
}